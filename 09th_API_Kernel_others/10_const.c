/*
 *
 *	kobey 2020年08月18日14:20:16
 *
 *	【一、基本介绍】
 *	const 是 constant的简写，并不是说，它修饰常量，而是说，它限定一个变量的属性为只读。
 *	(通过编译器，告诉别人，这个变量的存在应该怎么处理！)
 *	例如
 *		1，修饰(限定)普通变量、数组：
 *		const int a = 10;
 *		等价于
 *		int const a = 10;
 *		如果
 *		a = 9;
 *		这样编译就会报错，因为你在尝试修改一个属性只读的变量。
 *		由此也可以得知，如果使用const限定一个变量的属性，这个变量只能在申明的时候初始化。
 *
 *		2，修饰限定指针：
 *		修饰指针p指向的int型对象
 *		int const *p;
 *		此刻，指针指向可变，指针指向的对象只读。
 *
 *		修饰指针p本身
 *		int * const p;
 *		此刻，指针指向只读，不可变，但是指针指向的对象可变。
 *
 *		总结，按照我之前的经验，const修饰左侧，没有左侧就修饰右侧。
 *		或者，看在*号的哪边，就修饰那边。
 *
 *
 *	【二、怎么用】
 *	1，修饰函数形参
 *	char *strncpy(char *dest,const char *src,size_t n);
 *	int  *strncmp(const char *s1,const char *s2,size_t n);
 *	明显，我们可以看到源，src、s2的属性都是只读的，不可变。
 *
 *	2，修改全局变量
 *	很多时候，我们在使用全局变量的时候需要充分考虑全局变量使用的安全性，
 *	加入const限定修饰符，在一些场合可以利用编译器帮助我们更好的保护程序的安全。
 *
 *	【三、const修饰变量的属性为只读后，真的就只读了吗？】
 *	运行下面的程序，我们可以发现，引用一个指针，可以修改a变量的值！！！
 *	所以，答案就是：
 *	const修饰的变量，限制变量的属性只读，但并非可以在真正意义上切切底底的修改了变量的属性，
 *	它一是告诉编译器，通过编译器帮助我们拦截一些非法操作，发现这个变量在什么场合出现修改的
 *	行为，二是在警告我们程序员，不应该尝试修改！
 *
 *
 * */

#include <stdio.h>//现在的编译器可以做到，就算没有包含头文件，它也默认帮我们自动包含
int 
main()
{
	const int a = 2019;
	int *const p =(int *)&a;//强制转换，只是在告诉编译器，我知道自己在做什么事情
	*p = 2020;
	printf("const a = %d\n", a);
	return 0;
}
