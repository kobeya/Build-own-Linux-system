【探究编译器关于指令重新排序的优化规则】

	在内存管理-高速缓存的4、5、6中讨论过内存一致性的问题，也就是内存访问顺序的问题。
	目前，我个人认为
		1）cache一致性是侧重同步，某个地址数据是否一致
		2）内存一致性是侧重顺序，多个cpu访问不同地址，或者操作不同数据的顺序是否得到保障
			

	然后讨论了CPU指令乱序保障的问题，使用硬件支持并封装好的内存屏障指令保证执行顺序，
	比如smp_rmb,smp_wmb,smp_mb。

	并且这些指令其实包含编译器本身存在的优化规则。

	参考文章：
	译文，https://zhuanlan.zhihu.com/p/102406978
	原文，https://www.kernel.org/doc/html/v4.10/process/volatile-considered-harmful.html
	故事帖子：
	https://lwn.net/Articles/233482/
	https://lwn.net/Articles/233481/

	有个家伙提交一个patch，用了volatile修饰符，被pass了。。。

	
【为什么在Linux内核中不应该使用volatile】
	
	译文大意如下：
	
	1，volatile修饰符的目的是告诉编译器，抑制优化行为，这本身就不是我们真正想要的结果。

	1，内核访问的共享数据，本身应该而且必须使用某种形式的锁来保证不会出现竞争条件，
	这些环境下的数据其实已经包含内存屏障作用，这个锁住的资源已经变成不易变属性，
	其他进程完全没有办法在此刻访问，那么又何必加入volatile来多此一举，导致当前持有锁的进程
	继续访问内存地址呢？而且，锁本身也包含了volatile属性，编译器不会优化锁住的任何资源，
	这不就更加多此一举吗？

	2，还有一些其他场景的用法，，比如内存映射的I/O寄存器设计，这也就是volatile类型引入的早期
	初衷，但是，现在这些场景的接口已被封装好，而且也包含了防止不必要的优化，再次不需要volatile

	3，Linux中有个jiffies变量就是遗留的愚蠢问题，linus本人也说了
	这个全局变量一直在变化，而且没有锁保护，所以它的声明是volatile，那么为什么没有处理这个bug呢
	因为修复它带来的麻烦远比其价值更多，也就是得不偿失，干脆不修复。



	




