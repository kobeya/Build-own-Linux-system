本章主要描述内核同步的理解和策略
(1)导读大纲
	一、内核同步介绍
	1，临界区和竞争条件
	2，加锁

	二、内核同步方法
	1，原子操作
	2，自旋锁
	3，读-写自旋锁
	4，信号量
	5，读-写信号量
	6，互斥体
	7，完成变量
	8，BLK大内核锁
	9，顺序锁
	10，禁止抢占
	11，顺序和屏障

(2)主体内容

一、内核同步介绍1临界区和竞争条件
	1，背景
	从2.0版本开始，内核开始支持SMP，并从2.6开始，Linux已经发展成抢占式内核。
	这意味着我们代码执行的时候，必须保护好共享数据，避免出现不是我们想要的破坏。

	2，临界区和临界资源
		1）临界资源：每次只允许一个进程访问的共享资源。
			比如全局变量

		2）临界区：每个进程中，可以访问临界资源的代码段就称为临界区。
			每一时刻只允许一个进程进入临界区。
			通俗的描述，某个临界资源是共享但任何一时刻只能一个临界区可以访问属性，
			这个临界区就是可以访问临界资源的某个进程的代码段。不同的进程拥有不同的
			对应某个临界资源的临界区，当我们这些进程想访问临界资源的时候，只能一个进程
			进入临界区，并访问临界资源。

	某个进程P*|
		  |_
		  |_
		  |_
		  |.text------>这个代码段在执行的时候是否访问临界资源？ ---否---代码段不属于临界区
		  |_____						：	跟随其他调度
									：
									是，那么这个代码段就是临界区
									：
					    	      当前是否有其他进程在访问--否--进程进入临界区									：		
	【图1-代码段临界区属性的进程访问临界资源】		   有	
								   ：	
								等待在临界区的进程退出
								临界区内执行不可打断，就跟临界区
								是一个不可分割的一套指令。

		

	这里有一个疑问，n个拥有临界区的进程，竞争进入自己的临界区，进入之后，可以访问临界资源，
	并且这个临界区理论上可以被竞争其他的临界资源的进程抢占当前CPU，只不过后面来了一个
	优先级反转的问题，那么现在还可以打断吗？

	答1：不能被打断，我们必须保证在临界区内是不可分割，不可打断的。


	3，竞争条件race condition
	如果发生多个进程同时进入临界区，那么就称呼这种情况为竞争条件。	
	竞争条件是对已经发生同时访问临界资源的一个bug的情况的描述。

	


	综述上面的描述，小结：
	首先我们现在有一个共享资源，它可以被多个进程共享，我们称呼它为临界资源。
	那么此时，某一个时刻只能有一个进程进入自己的代码段，也就是临界区，并且进入后
	是不可以被其他想进入这个临界区的进程打断的，直到这个临界区结束返回。如果发生多个进程
	同时进入临界区，那么我们就称呼这种情况为竞争条件。
	其实临界区的描述这样理解更加合理：
	可以访问共享资源的进程的代码段，构成一个临界区，这个临界区就只能一个时刻，一个进程进入。

	怎么解决上面的问题？第二小节！

二、加锁
	
	1，Linux提供了各种锁机制，那么这些锁的主要区别是什么？
		答：主要区别在于，当某个线程持有锁，其他线程在等待锁时的行为表现。
		这些等待锁的线程的行为，是由锁来决定的。

	2，造成并发执行的原因？
		答：从CPU并发执行的角度分为两个方面
		1）单核cpu因为调度产生伪并发
		2）多核CPU可以真并发
		具体的原因有：
		1）中断，中断几乎可以在任何时刻异步发生，打断当前代码
		2）软中断、tasklet，内核能在任何时刻被抢占
		3）内核抢占
		4）SMP

	3，加锁的难度在哪？
		答：编写代码之初，就应该想好需要设计的锁，而且更重要的是，分辨在什么地方真正的需要锁

	4，这里给出一些安全区域的名称：
		1）中断安全代码：中断处理程序中避免并发的安全代码
		2）SMP安全代码
		3）抢占安全代码

	5，什么时候应该加锁？
		在任何可能被并发访问的数据，都应该加锁。
	
	6，死锁
		死锁，就是在等待一个永远得不到的锁。
		比如：最简单的死锁，自死锁，自己持有锁的情况下去试图再获得自己的锁。

		
	7，怎么避免死锁？
		1）按顺序加锁，锁在使用时如果需要嵌套，那么必须按照顺序来获取锁，避免出现
		抱死类型的死锁。
		2）防止发生饥饿，比如，某个持有锁的代码是否会一直执行下去，这样其他等待锁的代码
		也就出现，等待一个永远得不到的锁。
		3）不要重复请求同一个锁，自死锁
		4）设计尽可能简单


	8，争用和扩展性
		如果一个锁会被多个进程频繁的等待获得锁，那么说明这个锁是高度争取状态。
		这会带来一个问题：因为锁住的资源，会导致系统串行的访问，那么这就会导致系统性能瓶颈。
		而且降低扩展性，比如，你再多的core也没办法提供更大的性能了。
		怎么解决？
		我们可以尝试细化这个锁的资源。
		但是，这也引出一个问题
		锁太多，加锁过细，当争用不明显，就会加大系统开销，因为锁的本身，也需要消耗。
		所以这是一个权衡的问题，原则上，我们先力求简单，当需要的时候，再进一步细化加锁。
	


【第二部分	内核同步方法】

一、原子操作
	
	1，原子操作

		1）关于ARM Linux原子操作的实现，这个文件，我用一个单独一个文件来描述
		2）原子操作的数据类型atomic_t，为什么用这个数据类型
			a 可以确保原子操作，只与它的对应数据类型一起使用
			b 这个类型里面有一个volatile修饰词，保证编译器不做优化
	2，原子性与顺序性的比较
		原子操作只保证操作的原子性，也就是操作不能打断，要么不执行，要么执行完
		顺序性，保证执行的顺序，通过屏障来实现。

二、自旋锁spinlock

	1，等待锁的进程行为是忙等待，也就是不断查询锁是否可用，这段时间是特别耗费CPU资源的。
	
	2，所以，自旋锁的初衷：在短期内进行轻量级的加锁，持有锁的时间应该尽可能短
		（最好小于两次上下文切换用时）

	3，自旋锁方法
		1）定义
		自旋锁的实现与体系有关，代码基本使用汇编来实现，<asm/spinclok.h>
		实际使用的接口文件定义在<linux/spinlock.h>
		
		2）接口使用
		基本使用形式如下：
		DEFINE_SPINLOCK(mr_lock);//声明一个自旋锁
		spin_lock(mr_lock);
		/*临界区*/
		spin_unlock(mr_lock);
		
		注意：如果在单处理器上，没有自旋锁，它变成了一个是否可以抢占的开关，
		自旋锁的本身不会编译进系统。

	4，Linux内核中自旋锁不可以递归
		Linux内核中的自旋锁如果可以递归，自己持有锁的情况下去等待自己持有的锁，就变成自死锁
	
	5，中断处理程序中可以使用自旋锁，但是请注意，在获取锁之前一定要禁止本地中断。
		否则，如果在中断持有锁的情况下被其他中断打开，并试图获取锁，那么就会发生死锁。
		这个问题，自旋锁也同样有合适的接口：
		DEFINE_SPINLOCK(mr_lock);
		unsigned long flags;
		spin_lock_irqsave(&mr_lock, flags);//保存中断的当前状态，禁止本地中断，获取锁
		/*临界区*/
		spin_unlock_irqrestore(&mr_lock, flags);//解锁，然后中断恢复保存的中断的当前状态

	6，对自旋锁的调试
		内核提供有选项配置：
		CONFIG_DEBUG_SPINLOCK
		会帮我们测试到是否有自旋锁没有初始化、没获取锁就对锁进行开锁等等不合法操作
		CONFIG_DEBUG_LOCK_ALLOC
		会我们检测所有的锁。

三、读-写自旋锁

	1，读自旋锁，不允许写，写操作忙等待，但是读是并发安全的
	2，写自旋锁，不允许读写，因为读写并发都是不安全的，读写操作都需要忙等待


	总结自旋锁的使用：
	加锁时间很多，并且加锁过程不允许睡眠，比如中断处理程序中，使用自旋锁加锁。


四、信号量
	前面描述的锁-自旋锁，因为等待锁的行为是忙等待，所以自旋锁的加锁时间短、代码不允许睡眠。
	为了解决这种情况，引入信号量。

	1，信号量是一种可以睡眠的锁机制，等待锁的行为是加入等待队列，让出CPU。
	2，信号量自身的开销比自旋锁大，因为信号量需要维护睡眠等待队列以及唤醒的开销比较大。
	3，由于等待信号量的进程行为会睡眠，所以，进程只能在进程上下文中获取信号量锁，因为在
		中断上下文中，是不参与调度的。
	
	总结信号量锁与自旋锁的差别：
	1）信号量锁需要维护额外的睡眠队列、唤醒的开销，所以相对比自旋锁有更大的开销
	2）进程上下文是可以被抢占的，所以应该应该考虑信号量，中断上下文不能睡眠也不参与抢占，
		处理时间短，应该使用自旋锁。


	4，计数信号量和二值信号量
	信号量实际拥有一个特性，就是指定允许同一个时刻持有锁的进程的数量，也就是计数。
	如果计数大于1，则此刻计数信号量是可以被多个进程同时持有。
	如果计数=1，那么此刻二值信号量也称为互斥信号量，一个时刻只能被一个进程持有。
	在使用上，基本都是使用互斥信号量。

	5，信号量的P V操作
	由荷兰一位科学家1968年提出，
	p操作做down计数，就是对计数进行down操作，然后请求获得一个信号量，
	v操作做up计数，就是对计数进行up操作，当前持有锁然后增加计数，释放掉拥有的锁。

	6，创建和初始化信号量
	struct semaphore name;
	sema_init(&name, count);

	如果创建更为普通的互斥信号量
	static DECLARE_MUTEX(name);
	
五、读-写信号量
	定义一个读-写信号量
	static DECLARE_RWSEM(name);
	初始化
	init_rwsem(struct rw_semaphore *sem);
	读写信号量与读写自旋锁一样，在一些场合高效，但是使用的条件需要清晰明了。

六、互斥体
	1，互斥体与二值信号量的异同
	1）信号量用途更为通用，适用于那些较复杂、未明情况下的互斥访问，比如内核于用户空间复杂的交互
	2）为了找到一个更简单的睡眠锁，引入互斥体
	互斥体，可以指任何可以睡眠的强制互斥锁，当然包括计数为1的信号量。

	但是，在最新的内核，这个互斥体，更多的是描述一个实现互斥的特定的睡眠锁，它的实现比互斥信号
	量更加高效、限制更强

	总结：
		---二值信号量、互斥信号量	
	互斥锁 |
		---互斥体，简化版二值信号量，因为它不需要计数了。

	2，定义互斥体
	DEFINE_MUTEX(name);
	动态初始化mutex
	mutex_init(&mutex);

	mutex_lock(&mutex);
	/*临界区*/
	mutex_unlock(&mutex);

	3，互斥体深入探索
		我在前面简单的描述了互斥体与二值、互斥信号量的差别，但是没有深入，随口一提，
	描述到，互斥体比信号量的互斥属性更加强制、实现更加高效，那么具体表现在哪？
		1）高效性，实现互斥体，不需要计数，mutex的计数永远是1
		2）信号量可以在内核与用户之间交互的复杂场景，但是互斥体不可以
		因为互斥体，必须在同一个上下文中上锁和解锁。
		3）当持有一个互斥体mutex锁的时候，进程是不可以退出的。
		4）mutex当然不可以在中断上下文中使用，也不可以在下半部中使用
		5）内核也提供了mutex的调试、侦测功能CONFIG_DEBUG_MUTEXES

	4，在使用的时候，怎么选择信号量和互斥体？
		一般优先考虑互斥体，除非mutex无法满足或者场合非常特殊才会考虑信号量

	5，何时使用自旋锁、信号量、互斥体？
		中断上下文、或者临界区很简短的时候使用自旋锁
		进程上下文或者临界区很长的时候使用互斥体。

七、完成变量

	前面描述到，一个进程持有信号量，另外一个进程就会被迫进入睡眠队列，等到信号唤醒。
	那么有没有什么办法可以简单的替代这样的一个信号量？
	答：有的，内核提供一种简单代替信号量的机制---完成变量
	它的原理跟信号量一样，一个进程持有完成变量，那么另外一个进程就会等待，当持有完成变量的进程
	完成了它的工作，就会发信号给等待完成变量的进程，唤醒。

	静态创建并且初始化一个完成变量：
	DECLARE_COMPLETION(mr_comp);
	init_completion(struct completion *);
	
	等待接口：
	wait_for_completion(struct completion *);
	发起信号唤醒：
	completion(struct completion *);

	实践举例：vfork创建子进程完成后会调用完成变量，唤醒父进程



八、大内核锁 BLK

	到这里，有没有一个疑问，信号量在1968年就有了，是不是Linux一直都是这样用的？
	答案，当然不是。

	早刚出来SMP的2.0 2.2版本期间，Linux使用BKL，大内核锁。
	1，BKL是一个全局锁（全局自旋锁，但是却可以睡眠，而且只能在进程上下文中使用，等待锁的进程忙）
	2，BKL可以递归，因为使用kernel_locked的时候会检测当前是否被持有
	3，SMP中，BKL被持有，会禁止内核抢占
	4，BKL保护的临界区，不是临界资源

	lock_kernel();
	/*临界区
		1）对其他所有的BKL用户进行同步
		2）可以安全的睡眠，因为此刻锁会自动释放了
		3）睡眠中可以被唤醒调度，然后这个锁又自动获取
		4）还可以递归，因为不会自死锁
	*/
	unlock_kernel();


九、顺序锁seq锁

	同样，前面描述了读-写信号量，读-写自旋锁，这两者都类似，可以同时多个进程获得读锁，不可写，
	只能一个进程获得写锁，不可读。
	有没有一种锁，在读的时候可以写，在写的时候也可以读？
	答：有，现在已经有一种优化的读写锁---顺序锁，主要通过维护一个序列计数的值来维护锁的机制。
	工作原理：
	在读的时候，会记录读之前的序列计数的值，然后读完，比较读完之后的序列计数值，如果一样，说明
	在读的期间没有写，如果不一样，说明已经写了，那么再重新读，直到没有写为止。

	在写的时候，可以读，写优先级更高，随便你读，反正你读完后会比较写序列计数。

	1）定义一个seq锁：
		seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);
	2）写锁
		write_seqlock(&mr_seq_lock);
		/*写锁被获取*/
		write_sequnlock(&mr_seq_lock);

	3）读锁
		unsigned long seq;
		do {
			seq = read_seqbegin(mr_seq_lock);
			/*读数据*/

		}while(read_seqretry(&mr_seq_lock, seq));


	总结：当我们希望在读的时候可以写，而且写的情况很少，更多的是读，那么我们可以考虑顺序锁。

	实践举例：
	在内核时间定时器中，维护的一个jiffies变量就是使用了顺序锁编码。


十、禁止抢占
	
	1，前面描述的各种锁，基本都用在避免不同CPU之间的抢占，但是同一个CPU，就无需加锁，而是采用
		禁止抢占，更加高效。
	2，接口与用法：
		可以嵌套使用（必须成对、并且按照顺序）
		preempt_disable();
		/*禁止抢占，然后做你想做的事情*/
		preempt_enable();
		
		多个嵌套，可以使用接口查看嵌套计数
		preempt_count();//返回抢占计数

	3，禁止抢占还有一种更加简洁的接口：
		int cpu;
		cpu = get_cpu();
		/*执行get_cpu会关闭内核抢占，并把cpu设置为当前*/
		put_cpu();

十一、顺序和屏障
	
	1，顺序
		我们可能需要读写的某些排序问题，比如，按照某个顺序写，某个顺序读

	2，确保顺序的指令，就称为 屏障barriers
		所以，屏障是一种可以提供维护顺序的指令。

	3，不同的体系结构，屏障的实际效果差别很大
	
	常用接口说明
	1）rmb();	阻止跨越屏障的载入动作发生重排序
	2）wmb()	阻止跨越屏障的存储动作发生重排序
	3）barriy()	阻止编译器跨屏障对载入或者存储操作进行优化
	等等
	后面我应该会用一个单独的章节描述内存屏障的前前后后。

	
十二、总结

	
	中断不可以睡眠也不参与调度，应该考虑自旋锁，如果临界区小，也应该考虑自旋锁。
	进程上下文，可以睡眠也参与调度，应该考虑信号量，甚至优先考虑互斥体。
	如果按照一些特定的需求，我们还可以考虑一些读写锁、完成变量、禁止抢占等不同的机制。	

		

		


