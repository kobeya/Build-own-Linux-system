/*
 *
 *	（GNU GPL）kobey
 *	关于一份代码的bss段、data段以及代码段的分析
 *	1，简单描述data段与bss段对内存的占用情况
 *		1）data段是存储初始化不为零的全局变量或者静态局部变量
 *		2）bss段是存储初始化为零或者没有初始化的全局变量和静态局部变量
 *	
 *	2，data段在编译的时候就已经分配磁盘空间，因为它的数据需要真实的物理内存来做映射
 *
 *	3，bss段在编译的时候，会分配堆空间虚拟地址映射内存，所以bss段不会占据磁盘空间，不需要
 *		真实的物理地址作为映射。
 *		也就是bss段，不会占据磁盘空间，它的内容映射到堆空间的虚拟地址中，这些虚拟空间
 *		内存初始化为0，我们可以这样理解，所有的bss段，都映射到一块不存在物理内存的
 *		虚拟的匿名页中。所以有时候我们在优化堆空间的时候，也应该注意bss段对堆空间的
 *		影响，它会占据一些虚拟内存空间。
 *
 *	4，bss段没有太多需要优化，因为它用的是虚拟地址空间，只不过我们需要注意的是，在优化堆空间的
 *		是受到bss段的影响的。
 *
 *	5，data段的优化
 *		这个就涉及到非常多，我们可以建议，特别是共享库的数据段进行优化，当然如果是官方的
 *		共享库，那么我们就应该谨慎处理，如果是我们自己编写的共享库的代码，那么优化的
 *		空间应该是值得考虑的。
 *		1）尽可能减少全局变量和静态变量，因为它在正常使用情况下，初始化不为零是需要占据
 *		真实的物理内存，我们可以使用readelf -l 查看一个文件的大小，虚拟内存映射的大小。
 *		2）如果一个变量，你确定它只需要读即可，那么就加上const修饰符，让它保存在只读
 *		代码段，利用代码段是系统共享的特性达到节省内存使用的目的。
 *		3）不推荐在头文件中定义变量
 *			比如在头文件定义一个static全局变量，那么每一个引用它的单元
 *			都会创建一个同名但不同地址的全局变量，在一些场合就浪费内存等
 * */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *s1 = "hello world!";
char s2[] = "hello world!";

int main()
{
	printf("%s\n", s1);
	for(int i = 0; i< 13; i++) {
		printf("%c",*(s1+i));
		if(i == 12){printf("\n");}
	}
	return 0;
}
























