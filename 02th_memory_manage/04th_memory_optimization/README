主要介绍系统的内存优化
1，如何评估一个进程的内存使用
	cat /proc/pid/***

2，如何描述一个进程的内存使用
	1）堆空间的使用，malloc、brk、sbrk、mmap、mallopt、内存碎片、内存空洞
		优化角度
		尽量减少小块内存的申请
		通过mallopt动态调整堆的分配策略是brk还是mmap，降低内存空洞的风险，利用时间换空间
		通过mallopt动态调整堆回收策略，比如128KB改小一些等

	2）栈空间的使用，无系统调用，页故障分配，所谓的释放其实就是一个对程序员透明的复用过程
		实际上没有回收，栈的空间等于进程的最大栈空间。
		优化角度
		尽量避免在栈段分配大块内存
		尽量避免使用递归函数		


	3）环境变量，编译存储位置，新增环境变量与修改环境变量对内存的影响
		不管是修改还是新增，都无法在栈顶分配新的内存空间，都会在堆中分配新的内存
		优化角度
		编译的时候或者程序启动之前就应该设置好一个程序的环境变量
		程序运行后，就不要修改或者新增环境变量了	
	4）数据段与bss段的优化

	5）代码段的优化
		Thumb指令集	

	6）动态库的静态加载和动态加载优化

3，如何从系统级别调整内存使用
	1）守护进程的内存使用

	2）tmpfs分区

	3）page cache与buffer cache

	4）内存回收
		dirty page与LRU

	5）/prco/sys/vm下各个接口的策略性优化
		比如控制写回等

4，实际工程问题：
	1）如何发现内存泄露
		两种测试方法
		a，模仿用户长时间大量使用设备，做一个高压测试，系统测试
		b，针对某个具体的测试用例，检测是否存在内存泄露，单元测试

	2）如何定位到内存泄露的代码
		总的来说，比较可靠的方式是用各种检测工具和手法，连自己都不应该相信自己的代码，因为
		你调用的接口，对当前的你是隐藏的，但是却存在内存泄露的问题。
		a，在代码中加入mtrace函数，它会检测它下面的代码执行申请释放内存的情况，
			请注意，这个函数的本身，我使用valgrind工具去检查，发现本身就存在2次泄露！

		b，glibc中提供的malloc,free,realloc,memalign的钩子函数然后，再配合脚本和nm工具定位到
			具体哪行代码

		c，Dmalloc开源工具，在编译的时候链接libdmalloc.a，它的实现原理是用内部自定义的函数
		替换代码中使用的malloc、realloc等函数，获取控制权，然后运用自身的代码去跟踪和检测
		堆内存的分配释放。

		d，valgrid，模拟CPU，相当于跑在一个虚拟机中，获取各种有用信息，非常厉害的工具，
		缺点就是在运行程序的时候会加入很多调试信息，然后跑在虚拟环境中，速度比较慢等。



















