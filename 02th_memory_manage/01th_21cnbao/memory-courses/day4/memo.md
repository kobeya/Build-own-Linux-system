主题：内存与I/O的交换

一、摘要
	1，page cache
	2，free命令的详细描述
	3，file-backed的页面和匿名页
	4，页面回收和LRU
	5，swap和zRAM


二、page cache
	
	1，定义:又称为pcache，页高速缓存器。page cache的大小为1页，在IA32中为4Kib。
		在Linux读写文件时，它用于缓存文件的逻辑内存，从而加速对磁盘上镜像和数据的访问。


		APPs ----------读写------> 内核<----映射----- page cache ----------->磁盘文件
		     <--------读写------ 用户空间 <--映射-----page cache -------->swap分区匿名
		
	2，缘由:当你在Linux下频繁存取文件后，即使系统上没有运行许多程序，也会占用大量的物理内存。
	这是因为当你读写文件的时候，Linux内核为了提高读写的性能和速度，会将文件在内存中进行缓存，
	这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory 也不会自动释放，
	这就会导致你的Linux系统在频繁读写文件后，可用物理内存会很少。

	
	3，Linux下读写文件，主要有两种方式：
		① read/write
		在调用read读文件的时候，内核会申请一个page cache，然后把文件读到page cache中，
		再将内核空间的page cache拷贝到用户空间的buf。
		比如
			fd = open(***,O_RDWR);
		这个过程发生了什么？
		首先，使用open函数，打开一个文件，先是在内核空间申请一个page cache，然后
		把文件拷贝到page cache，生成一个指向内部数据结构的指针到文件描述表，返回
		一个文件描述符表的索引值fd，在windows上，也称为文件句柄。

		调用write写文件，则将用户空间的buf，拷贝到内核空间的page cache。

		② mmap
		mmap可以避免buf从用户空间到内核空间的拷贝过程。

		直接把文件映射成一个虚拟地址指针，这个指针指向内核申请的page cache。
		内核知道page cache与硬盘中文件的对应关系。

		简单的说，就是一个是使用read write接口做page cache的拷贝
		一个使用mmap接口做page cache的虚拟地址指针索引，避免拷贝耗时。


	4，file-backed的页面和匿名页
		file-backed映射，把进程的虚拟地址空间映射到files，
		比如 代码段，进程的虚拟地址空间对应的VMA是映射到实际的files的。
		这些想文件背景的页面，在长时间不在使用的时候，内存紧张的状态下，会被置换到swap分区，
		就不再驻留到内存了。

		
		匿名页，进程的虚拟地址空间没有映射到files，
		比如，stack、heap和COW机制下的内存分配。
		当不再使用这些匿名页，也是会通过swap分区置换，只不过，这里有个差异：
		内核关闭CONFIG_SWAP的时候，只是关闭了匿名页的swap置换，对于有页面背景来说，
		还是会内核中的kswapd守护线程管理置换swap分区。

		Linux的的kswapd守护线程，对Linux内存的消耗有3个水位，
		用剩余的可用内存作为划分：min low high
		当内存达到低水位，后台就自动开始回收到高水平；
		若是内存水位到min，内核就会直接堵住进程，先做内存回收。
		|
		|——————————high	剩余内存很多
		|
		|——————————low 剩余内存很低 ----->后台自动开始回收内存，直到high
		|——————————min 剩余的内存危险 ---->堵住进程，先进程内存回收

		设置/proc/sys/vm/swappiness,这个值较大，会倾向回收匿名页，较小，倾向于文件背景的页。
		回收的算法，均采用LRU，也就是最近最长时间没用的内存就先回收。


三、页面回收、LRU(Least Recently Used)、swap和zRAM

		这章相当于一个总结：

	1，页面回收，我们前面描述到，不管读还是写磁盘文件，都会在内存中申请一个page cache，
	当申请多了，内存就不够用，这时候，需要回收内存。

	2，内存的回收，使用LRU，最近最少使用算法，把内存置换到swap分区。
	这个swap分区，也有讲究，在嵌入式，内存很少的平台上，一般都会swapoff，也就是没有使用swap
	分区，那么就会使用一种机制，zRAM！
	前面也有说过，当我们程序的page cache需要回收，那么page cache的文件就会置换到swap分区，
	此刻，进程的虚拟地址的映射就会消失，也就是没有映射了，如果再次访问，就会发生page fault，
	再通过I/O操作读取swap中的数据到内存，重新建立映射。

	3，zRAM，zRAM的出现，是为了解决嵌入式少flash的情况下，在内存中申请一块内存，模拟成一个
	一个硬盘分区，用作swap分区使用。
	（磁盘是SD卡,MMC,一方面速度较慢,另一方面,有使用寿命的问题,不太适合做swap分区）
	
	这个分区自带透明压缩功能，效果可以说是，消耗CPU时间，增加内存容量，但是这个容量的访问，
	依然跟硬盘的swap分区一样，需要page fault。
	
	zRAM直接把一块内存模拟成一个硬盘分区，当作swap分区使用，此分区自带透明压缩功能，
	当匿名页向zRAM分区写时，Linux内核使CPU自动对匿名页进行压缩。接下来，当应用程序又
	执行到刚才的匿名页时，由于此页已经被swap到zRAM中，内存中没有命中，页表也没有命中，
	所以此时再去访问这块内存时再次发生page fault，Linux就从zRAM分区中将匿名页透明的解压
	出来还到内存中。
	zRAM的特点是用内存来做swap分区，透明压（两页匿名页有可能被压缩成一页），
	透明解（一页解压成两页），这样其实相当于扩大了内存，但会多损耗一些CPU。
	


				

四、swappiness
	前面描述了cache、buffer，那么我们怎么平衡这两者的回收呢？
	通过设置/proc/sys/vm/swappiness的值来确定在内存回收的时候，倾向于哪个类型
	swappiness越大，越倾向于匿名页的回收，越小，越倾向于有文件背景的内存回收。
	当然，回收算法都是LRU。
	还有，这个swappiness的值，同时反应，是否积极的使用swap分区。
	我们也知道，一般来说，LRU是倾向于先回收匿名页的。




