【一致性2-内存模型】
	1，TSO
	2，PSO
	3，RMO


【一、内存一致性模型-TSO】

	1，TSO，Total Store Order，完全存储定序 内存模型
	我们作为软件工程师，从内存模型的角度理解代码的执行流程，让代码更符合硬件最佳性能。

	2，CPU在L1 cache之间，引入一个可以理解为L0.5的cache--->store buffer
	速度在1个指令周期，而且它只缓存CPU的写操作，或者读取写的数据，也就是曾经写的数据尝试命中。
	目前简单的理解，它是优化L1和MESI带来的同步等待变成异步化，从而提升性能。
	MESI协议在前面的文章描述了，硬件上通过消息事件通知其他L1 cache同步，实现一致性。


	3，CPU、store buffer、cache之间如何工作


		CPU---写数据------------------->store buffer
							|
							|
				            后续以FIFO的方式写回L1 cache	


	还记得前面描述的MESI，它是维护cache的一致性，但是却不保证store buffer的一致性，
	那么问题就来了


		如果CPU0写一个数据到store buffer，那么CPU1在一瞬间是不能及时看到的，
		因此
		乱序执行，会影响多核！（单核就透明了，你一个cpu怎么执行，最终同步到cache，无所谓）


	4，怎么解决，使用硬件支持的内存屏障指令，比如smp_mb()操作，将读写操作顺序化。


【二、内存一致性模型-PSO】
	
	上面描述了TSO模型，采用FIFO的策略来更新cache保证访问一致性，但是这个情况还能继续优化，
	比如，如果我们认为某些变量真的对顺序无关，那么能不能优化它？

	答：当然可以，这就引入PSO模型，Part Store Order，部分存储定序。

	同样，Linux内核提供了smp_wmb()宏对不同架构的指令进行封装，这是一个读写顺序指令。



【三、内存一致性模型-RMO】
	我们能不能完全乱序，这样性能不是更好？
	答：没错，确实存在这个模型，而且我们现在aarch64（常见的手机）就是典型的这种模型。
		RMO，Relaxed Memory Order，完全乱序。


	1，引入一个新的读屏障smp_rmb()。
		smp_rmb()保证屏障后的读操作不会乱序到屏障前的读操作，只针对读操作，不影响写操作。

	
	2，简单总结，因为架构不同，底层实现的细节也会不同，但是我们可以使用封装好的内存屏障指令
	来保证我们内存一致性。





