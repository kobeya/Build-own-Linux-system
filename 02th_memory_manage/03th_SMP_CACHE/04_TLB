【导读】

	含糊的说，TLB是MMU的一块cache，它缓存着VA-PA的关系，CPU访问一个地址首先查找TLB是否命中，
	如果命中，直接返回物理地址，无需经过MMU多级页表的查找，效率得到提升。

	但是，TLB究竟是怎么做到这些的呢？它的实现原理是什么？需要克服什么困难？



1，TLB究竟是什么？
	TLB本质也是一个速度比常说的cache速度更快的cache硬件。

2，TLB是VIVT查找命中，那么会遇到前面描述的别名、歧义的问题吗？如果遇到，怎么解决？
	这就涉及到TLB的实现原理，或者说它相对常规cache的特殊性。
	1）TLB不存在别名的问题。
	2）TLB也不存在歧义的问题
	怎么做到的，这取决TLB的组织架构


	每一项TLB里面保存一个虚拟地址对应的物理地址，而且它还有以下字段：
	1）ASID，Address Space ID，用于区分不同进程的地址空间，ASID一般8bit或者16bit
		由进程的task_struct管理，不等同与pid	
		8bit的ASID可以标识256个常活跃的进程，注意是常活跃
		16bit的ASID可以表示65536个常活跃的进程

		怎么管理ASID
		ASID在进程task_struct中的管理页表的基址寄存器中的空闲位，
		然后在进程上下文切换的时候，刷新到TLB的ASID中。
		当ASID分配满了，就会Flush TLB重新缓存ASID
		当发生进程上下文切换，对应的ASID就会填写到TLB中了

	2）nGbit，也就是用1个bit来标识当前地址是对应用户空间还是内核空间，
		内核空间地址，是所有进程共享的，也就是说，不管是什么进程，这个地址空间是一致的，
		那么当查找的时候，也就无所谓查询ASID，直接先比较tag是否命中，然后再查询nG bit，
		如果是global也就是内核空间，那么就直接判断TLB hit，否则再去查询ASID



3，描述一下当CPU访问一个地址的时候，在TLB可能需要做哪些事情

	CPU--------------VA-----------------TLB
					     |
			        ----tag命中-----------tag不命中 -----> MMU中多级页表查找
			  	|
	   global标志位置位--------------global标志位不置位
		|				     |
      命中，返回内核空间的物理地址        硬件判断ASID与当前页表基地址寄存器中保存的ASID是否一样
					 |						|
				       不一样					       一样
					 |						|
				       查找MMU					       命中
		



	所以，在进程切换的时候，会更新我们的ASID的值，这样可以让TLB的命中更有效，而不需要每次都要
	Flush整个TLB。



总结，
	TLB的组织特性可以让TLB在VIVT访问不会出现别名或者歧义
	而且TLB的访问字段中有gobal的标志位nG bit和每个进程的ASID字段
	可以有效的提升TLB的性能。




