【内核回顾】


1，	如果一个进程试图修改它的正文段，会发生什么？
	答：会发生错误。正文段唯一可以修改的机会，就是打断点，此时会结束正文段共享。

2，	我们知道，进程的栈在动态的增加，但是就算局部过程返回，内核在实际上也不会缩小栈的空间，
	这里发生了什么？
	答：回到这个问题，从两个角度分析
		1）在一个进程中不断的调用其他子例程，那么就可能需要不断的分配栈空间，
		如果每次调用一个例程就重新分配扩充栈空间，将会非常耗时，所以，内核的决策是
		栈空间保留，如果栈空间超出了，那么超出部分就是未定义内容。
		2）如果一个进程栈空间一直保留，但是却没有继续使用，而且内核出于其他目的需要
		内存空间的时候，可能就会把当前进程很久没有使用的栈空间swap出去。
		这些我们目前都几乎没有非常有效保证的逻辑条件去识别。

	总的来说，进程自己不管收缩自己的栈空间，但内核在管理内存空间的时候会管理栈内存。

3，	使用fork不管迭代创建多少个新进程，在没有写之前都共享同一份拷贝，而且中途有进程扑街，也不会
	影响到其他进程的状态。

4，	如果使用COW技术，子进程在创建的时候不需要分配物理页，它与父进程所有的共享地址空间。
	如果不使用COW技术，那么父子进程在创建的时候，除了只读的代码段，其他
	就需要分配新的物理页来做一个拷贝。


BUG	这里留一个flag，
	没有COW技术的代码段怎么个表现方式

5，	fork出一个子进程后，对data段分别做一次带缓冲的read系统调用和write系统调用，发生了什么事情？
	答：
		1）read的时候会把内核中的数据写到data段，引起缺页异常，执行缺页处理
		2）write的时候把data段的数据读到用户，没有其他事情发生。


