目录：
一、Linux对中断的扩展：硬件中断，软件中断
二、中断处理原则1：不能嵌套
三、中断处理原则2：越快越好
四、要处理的事情实在太多：拆分为上半部、下半部
五、下半部的事情耗时不是太长：tasklet
六、下半部要做的事情太多并且很复杂：工作队列
七、新技术：threaded irq




一、Linux对中断的扩展：硬件中断，软件中断
	

	硬件产生的中断----------->硬件中断|
					  |--->中断号----->中断处理函数	
	人为、软件设计的中断----->软件中断|



二、中断处理原则1：不能嵌套
	https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc
	上面的patch提到，如果中断可以嵌套，那么可能导致stack overflow，栈耗尽。
	按照我现在的理解，其实还需要考虑其他因素，比如，中断不能在进程上下文中一样调度，而且中断
	处理返回，就直接执行下一条指令了，并不像缺页异常，会执行同一条指令。

三、中断处理原则2：越快越好
	中断处理过程中，是无法调度的或者响应的(如果还来中断，就pending)，此刻，
	当然希望中断处理越快越好。

	使用request_irq注册中断处理程序。


四、要处理的事情实在太多：拆分为上半部、下半部
	中断下半部的实现方式有三种机制：
	1，软中断
		软中断是一组静态定义的下半部接口，有 32 个，
		可以在所有处理器上同时执行，类型相同也可以；
		在编译时静态注册。
				
		软中断流程：
		注册软中断open_softirq--->触发raise_softirq--->执行do_softirq
		do_softirq{
			if(in_interrupt())--->判断当前是否在中断处理状态，是，就直接返回
				return;			也就是说，软中断不参与抢占。
			local_irq_save(flags);--->保存现场，也就是当前寄存器的值到内核栈
			pending = local_softirq_pending();--->获取中断处理程序

			__do_softirq();
		}
		从do_softirq可以看出来，这个过程，是参与抢占的，也就是软中断的处理过程中，
		可以响应其他中断。

		总结：软中断可以在其他处理器上被抢占，同类型的软中断可以在其他处理器同时运行，
		因此需要对临界区加锁。

		软中断，用在对时间要求最严格的下半部，比如网络、内核定时器。


	2，tasklet(也有称呼为小任务)
		基于软中断实现
		不同类型可以在不同处理器上同时运行，但是同类型就退出函数。
		允许抢占，但不能睡眠。


	3，work queue(工作队列)
		将下半部工作，交给内核线程执行，可以睡眠。
		工作队列实际上是一个链表，工作线程作为死循环，链表空时休眠，不空是执行每一个工作。 
		
七、新技术：threaded irq
	前面描述了，工作队列需要内核线程来调度执行，但是调度也需要维护，再优化一下，就得到我们的
	新技术。
	
	request_threaded_irq接口

	通过这个接口，内核帮我们创建一个内核线程。
	当发生中断的时候，就执行这个函数即可。
	这样，就可以在SMP系统中，均衡的处理不同的中断。


	
