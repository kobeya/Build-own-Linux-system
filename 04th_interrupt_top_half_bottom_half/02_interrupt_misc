主题：中断杂项，在编写主体内容前的思想准备

一、ARM环境
	1，ARM处理器7种模式
	
	非特权模式 |					特权模式
		非异常模式          |		             异常模式	
		   |		    |
	USR用户模式|	SYS系统模式 |	IRQ中断	   FIQ快中断	SVC管理	   ABT终止	UND未定义	
	从上面可以看到，ARM7种运行模式中，只有一种非特权模式，就是用户模式，其他6种都是特权模式。
	再按照异常角度来分，有2种非异常模式，USR+SYS。
	有5中异常模式IRQ FIQ SVC ABT UND。

【再第n次翻阅Linux内核设计与实现】

二、中断和中断处理
	1，响应一个中断--->特定的IH、ISR
	2，中断处理程序IH Interrupt Handler 中断服务例程Interrupt server routine
		其实就是按照特定类型声明，符合内核标准传递信息的c程序。
	3，ISR运行在中断上下文，这个中断上下文，也称为原子上下文，因为在这个上下文中不可阻塞。
	4，内核的中断处理，基本上只做一个响应中断的操作，剩下的事情，交给下半部处理。
	这里留个问题，下半部什么时候执行，以及下半部过程出现中断怎么处理？

	5，这里也留一个问题，系统怎么实现中断信号线共享？
		回答1，在申请注册中断处理程序的时候，我们可以通过第三个参数指明中断程序共享中断线，
		然后在第五个参数dev，一般指向申请中断处理程序的对应的数据结构实体针对来标识自己。
		在共享中断线的时，它在处理一个中断的时候，会屏蔽中断线上的其他中断，只是说共享
		ISR而已。


	6，注册中断处理程序
		int request_irq(unsigned int irq,//中断号，可以预先指定，也可以动态申请，探测获得
				irq_handler_t handler,//ISR，指向实际中断处理程序
				unsigned long flags,//标志位掩码，一般为0，也可以根据使用场景调整
				const char *name,//中断设备ASCII文本，/proc/irq、/proc/interrupts使用
				void *dev);//dev_id，用于共享中断线，指明中断线上的哪个中断处理程序
		这里的void *dev，非常重要，5的时候，提到一个问题，系统怎么实现中断信号线共享？
		这里就可以找到一些答案：
		在申请中断处理程序，注册的时候，传递的最后一个参数，也就是第五个参数，用来指定
		申请的中断处理程序的参数dev，然后我们就可以在共享中断线的时候，知道哪个中断处理程序
		是属于自己的，简单的说，就是这个参数，在共享中断线中的标志字段。


	7，request_irq可能会睡眠，所以不能在睡眠不安全，也就是不允许睡眠的地方调用。
	比如，不能在中断上下文中，也不能在不允许阻塞的上下文中调用。

	8，注册中断程序，为什么会睡眠？
		分析下过程：
		

		request_irq的第四个参数中，会在/proc/irq、/proc/interrupts中创建一个ASCII文本的名字，
		就会调用proc_mkdir函数，这个函数最终会调用kmalloc分配内存，这个API是可能睡眠的。


	9，请注意，在编写驱动的时候，必须，要先做完硬件的初始化，再注册中断处理程序。
		通俗的理解是，首先我们得让硬件处于正常可工作状态，再注册中断处理。


	10，释放中断处理程序
		1，注销中断处理程序
		2，释放中断线

		void free_irq(unsigned int irq, //共享中断线
				void *dev);//前面谈到，这个是在共享中断线中标志自己的中断特例

		这里可以总结，这个dev有多重要，不管是否共享，都唯一的标志中断处理程序。


		第一个参数，是一个中断号，也是一个中断共享线，当出现这类中断的时候，就会跑到
		这类共享中断线中，查询对应dev的中断处理程序，原来我们也可以理解，中断号对应
		注册的中断处理程序，但是如果细分，还有一个dev标志字段，来从这一类中获取对应的
		处理例程，然后删除的时候，也根据dev从中断共享线中删除对应的ISR。

		引用下2.0以前的内核，没有dev这个参数，确实会发生，多个设备共享同一个ISR。
		现在有了dev，中断号后续的作用就在打印的时候来条信息作为提示了。


	11，编写中断处理程序
		static irqreturn_t intr_handler(unsigned int irq, //中断号，共享的中断线，类别
			|			void *dev);//从中断号、共享中断线中标识自己
		使用这个类型的返回类型，是为了与早期的内核保持兼容，
		实际上是一个int型。

	12，请注意使用static，因为它从来不会在别的地方直接调用。

	13，中断处理程序在执行期间，不可重入。
		首先我们要清楚，共享中断线，只是说，别的中断可以共享它，但不代表可以同时执行。
		在我们执行一个中断处理程序的时候，在同一个中断线上的其他中断会被屏蔽。
		但是其他的不同中断线，是可以响应的。

	14，我们怎么确保，硬件怎么的发生中断？而不是假中断呢？
		首先，软件在逻辑上要处理，如果是假，马上退出。
		然后，硬件在设计上也要检测，使用状态寄存器查询或者类似手段等去探测是否真的发生中断

	15，中断上下文
		当执行一个ISR的时候，内核就处于中断上下文，也就是IRQ的特权、异常模式。
		中断甚至可以打断在其他中断线上的中断处理程序，那么被打断的中断怎么处理？

		中断处理程序也需要自己的栈。
		这里扩展一下：
		内核在创建进程的时候会为进程分配两个栈，内核栈和用户栈。
		
		用户栈，有些描述不够准确的文章，一直在描述，堆栈的空间好像是无限的，其实这句话
		对，也是不对，我更希望脑子里保持它是不对的想法。
		因为用户栈，大小是有限制的，一般为8M，当函数嵌套过多，可能发生栈溢出！
		当然，我们可以手动扩充栈的大小，比如
		ulimit -s修改栈的大小，比如扩充到100M
		栈自动分配，自动回收，不存在内存泄露
		那么为什么栈的大小受限
			
	16，内核栈与中断栈
		早期，中断栈与内核栈共享8KB，64bit的是16KB，后来，内核栈为了节省内存，缩减到4KB，
		64bit的是8KB，中断栈就独立出来了，大小为1页。

		到这里，结论很明显了，每个进程拥有独立的用户栈、内核栈。
		中断也拥有自己独立的内核态的中断栈，大小4KB。

	17，中断处理机制的实现

		
	18，/proc/interrupts
		虚拟文件系统，只存在与内核地址空间。
		在proc文件系统节点下的操作都是通过内核函数来完成的。

	19，中断控制
		程序员做中断控制的原因，是需要提供同步。

		早期，内核使用cli();来全局控制系统的中断并发，然后使用sti()；激活
		这些接口在2.5版本就取消了，使用本地中断接口+自旋锁来管理。


		① 禁止中断，可以做到屏蔽当前CPU的中断线，保护当前CPU的临界区。
			local_irq_disable();
			local_irq_enable();

			上面的接口存在问题，比如，在禁止中断之前，已经是处于关闭中断状态，
			是激活中断的时候，是无条件的激活中断，也就是不管什么状态，直接激活。

			这里的原因我看的不是很清楚，具体描述是这样的：
			内核希望一个给定的代码路径可以在禁止中断或者没有禁止中断的情况下，都可以
			访问。这跟中断禁止与否有啥关系？(第七章 p104 禁止和激活中断)

			反正这里的结论是：
			在禁止中断之前，应该保存当前系统状态，在激活中断的时候，不应该无条件激活，
			而是只需把之前保存的系统状态，恢复就好了。
			unsigned long flags;用flags来表示系统当前的信息，跟堆栈有关系。
			local_irq_save(flags);
			local_irq_restore(flags);
			而且请注意：这个优化的函数，必须在同一个函数内部调用，使用同一个栈帧，
			否则flags里面保存的信息就无法正常传递。
			
			




		② 持有锁，可以做到屏蔽当前系统(多核心)的并发访问。

		总结，禁止中断或者禁止内核抢占，都只对当前CPU有效，无法做到防止其他CPU的并发。
		防止其他CPU的并发，只能用锁。



		③ 禁止指定中断线
			不建议使用，这里就不展开了。

	20，中断系统的状态(甚至是整个系统当前状态的判断)
		有时候需要了解中断的状态，比如
		中断禁止、中断激活、中断上下文执行状态

			功能				API			通过返回值判断
		查看本地中断是否禁止：			irqs_disable()   禁止返回非0，没有禁止返回0
		中断上下文返回非0，进程上下文返回0	in_interrupt()
		当前处于中断上下文，返回非0		in_irq()			
					

		总结，也就是说，内核提供有函数，根据返回值去检测当前进程处于进程上下文，
		还是中断上下文，还是处于中断禁止等状态。


	21，文章有出现，中断甚至可以打断其他中断处理程序，希望后续能从这点继续深入。







	总结：中断只能通过中断处理程序实现，但下半部的就存在很多机制了。



三、中断下半部的实现
	
	1，下半部的环境
		现在Linux内核，提供三种不同形式的下半部实现机制：软中断、tasklet、工作队列
		上半部简单快速，执行的时候禁止一些或者全部中断。
		下半部稍后执行，执行期间可以响应中断。
		这里有个问题，可以响应中断这个机制的原理是怎么？下半部怎么唤醒，中断后怎么继续执行？

	2，内核定时器
		内核定时器，把操作推迟到一个确切的时间后，再执行。
		如果我们必须保证一个确定的时间段后，执行中断下半部，那么应该使用内核定时器。


	3，理清楚下半部机制
		BH			2.5版本后去除
		任务队列task queue	2.5版本后去除
		软中断softirq		2.3版本引入
		tasklet			2.3版本引入
		工作队列work queue	2.5版本引入


	4，下半部实现机制1——软中断
		① 软中断，很少使用，代码在kernel/softirq.c中，大部分驱动使用tasklet
		② 软中断的实现
			注册、分配
			软中断是在编译期间就动态分配的，最多只有32项，目前统计我们只用到9项。
			它定义在一个数组结构体中，编写代码的时候，静态注册软中断即可。
			注册open_softirq(***32项宏中的一项，处理程序);

			软中断处理程序
			softirq_handler ---> action。
			软中断处理程序的核心是一个参数为softirq_action结构体指针的action函数。

			标志软中断(触发)
			当中断处理程序返回前，标记它的软中断，使能它的下半部稍后执行。
			
			软中断执行时间点
			A 从硬件中断代码返回时
			B 在Ksoftirqd内核线程中
			C 在显示检查和执行待处理的软中断代码中，如网络子系统

			总结：内核用一个32项的数组定义软中断，在我们程序编译的时候，静态分配软中断，
			然后会在中断处理程序返回前标志软中断，并在返回后，或者内核线程Ksoftirqd或者
			显示调用软中断的地方执行。

		③ 软中断处理的核心
			A 使用一个局部变量pending来保存待处理的软中断位图
			B 做一个pending循环，执行对应位图的action，直到pending = 0
			C pending最多只能设置32项，循环最多只能32次。
			
			总结：软中断的执行核心是用一个局部变量pending保存所有的软中断位图，
			然后通过一个最多只能有32次的循环体来执行对应位图的action。


		
		④ 使用软中断
			A 软中断保留给系统中对时间要求最严格、最重要的下半部使用
				目前只有两个子系统用到软中断：网络、SCSI（磁盘传输之类的接口）
				理解下为啥这两个对时间要求严格：(以下是我个人理解)
				网络有个缓冲区，当从网络中读取到数据包放到缓冲区的时候，
				避免缓冲区溢出，应该尽快把数据放到内存。
				SCSI一样，当做硬盘数据读取的时候，IO操作会很慢，而且不收CPU干扰，
				所以应该尽快满足调度。

		模拟编写一套完整的软中断伪代码：

		静态声明新的软中断（一般不用新增，目前只用到9项，内核代码已经给了11项）
				enum
				{
					HI_SOFTIRQ=0,
					TIMER_SOFTIRQ,
					NET_TX_SOFTIRQ,
					NET_RX_SOFTIRQ,
					BLOCK_SOFTIRQ,
					BLOCK_IOPOLL_SOFTIRQ,
					TASKLET_SOFTIRQ,
					SCHED_SOFTIRQ,
					HRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on the
							    numbering. Sigh! */
					RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
	
					NR_SOFTIRQS
				};

		注册
				open_softirq(NET_TX_SOFTIRQ, my_action);


		中断返回前触发
				raise_softirq(NET_TX_SOFTIRQ);
				(在一些文章中看到过，触发软中断，实际就是给它的数值+1)	

		执行软中断
				do_softirq();




	5，下半部实现2——tasklet
		tasklet基于软中断实现，但是它接口比软中断更加简单，而且对锁的要求比较低。
		因为tasklet不允许同类型的中断同时执行。

		tasklet实际就是软中断中的两项实现的:HI_SOFTIRQ	TASKLET_SOFTIRQ
		这两者的区别在与HI_SOFTIRQ的优先级更高。

		① 每个tasklet用一个tasklet_struct结构体来表示，里面有个计数器，0表示激活，1表示禁止
		② tasklet由tasklet_schedule()和tasklet_hi_schedule()函数进行调度(两函数区别在优先级)
		也就是说，我们注册了一个tasklet，它在什么时候执行呢？
		答：先把tasklet的数据结构体指针tasklet_struct放到到tasklet_schedule里调度执行。		

		使用tasklet伪代码：
			使用宏，静态创建
			DECLARE_TASKLET(name, func, data);
			DECLARE_TASKLET_DESABLED(name, func, data);

			这两个宏，可以根据给点的参数，创建静态的tasklet_struct结构体
			
			动态创建
			tasklet_init(t, tasklet_handler, dev);


			编写必须符合规定的tasklet函数
			void tasklet_handler(unsigned long data);

			请注意，软中断、tasklet都可以允许抢占，也就是说，
			软中断执行过程可以被同类型或者不同类型的中断在其他处理器上同时执行，所以
			要加锁保护临界区。
			tasklet执行过程，可以被不同类型的中断在其他处理器上同时执行，也一样要加锁。

	
			tasklet_schedule();

		总结：
		tasklet实际就是基于软中断的两项来实现的，这两项的区别在于优先级。
		可以使用宏静态定义，也可以使用tasklet_init动态创建，
		他们可以在tasklet——schedule中执行。		


	6，ksoftirqd内核线程
		Q为什么需要Ksoftirqd内核线程？
		A答：因为在处理软中断的时候，软中断可以重新触发自己以便可以再次执行，比如网络子系统
		那么就存一个平衡的问题，软中断触发自己，是立即解决，还是不解决。
		立即解决，如果软中断的负载很大，就会影响到系统的性能。
		不解决，像网络这种机会丢包。

		所以，我们使用每一个CPU都有一个潜伏的内核线程Ksoftirqd，每个CPU序号作为区分
		当我们有软中断触发的时候，这个内核线程就会被唤醒，这个内核线程的优先级很低，nice
		值为19，然后它保证这个软中断肯定会执行，只是会在CPU负载很低的时候执行而已。

		这个内核线程，初始化之后，就在做一个死循环，只要有待处理的软中断，就会调用do_softirq
		处理。
		总的来说，使用这个内核线程来处理稍后处理软中断，并且肯定会出现。


	7，下半部实现3——工作队列（work queue）
		这个实现完全区别于上述的基于软中断实现的下半部机制。
		它的原理是，把下半部的工作，交给一个内核线程去执行，不像上面提到的交给内核线程去唤
		醒。
		工作队列，总是在进程上下文中执行，并且可以睡眠+重新调度。

		这里插入一个总结：
		如果我们需要一个可以睡眠、重新调度的下半部，比如处理信号量、阻塞IO等就用工作队列
		否则，考虑tasklet。


		① 工作队列的实现
		每一个CPU都有一个工作者线程，events/0 events/1 ...
		这个工作者线程用workqueue_struct来表示
		
		② 工作原理
		工作者线程调用一个worker_thread函数，执行一个死循环并开始休眠。
		当有操作插入队列，就会被唤醒，然后执行这些操作，如果没有剩余的操作，就会继续休眠。

		
		

	总结：
		如果考虑要求非常高的性能---软中断

		如果需要睡眠、调度---------工作队列

		如果不需要睡眠、调度，也不追求最好的性能，反而追求简单、安全---tasklet




四、下半部加锁

	1，一般我们需要先获得锁，然后再禁止中断。
	2，当然，我们也可以使用一些很极端的API，禁止所有的下半部中断。







		
			
		
			

							
			
	
	
