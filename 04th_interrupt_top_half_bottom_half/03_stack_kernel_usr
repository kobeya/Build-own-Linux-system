为了搞清楚整个中断上下文的问题，引出栈的使用，
这里特别加入一节，专门研究栈。

进程栈、线程栈、用户栈、内核栈、中断栈、软件栈、硬件栈等等词汇

一、ARM架构寄存器简介
	ARM拥有37个寄存器，这些寄存器按照部分重叠再组合的方式排列用于不同的系统模式。
	37个寄存器包括：
	1，30个32bit的通用寄存器
	2，每个组都包含15个通用寄存器+一些状态寄存器，通过寄存器有r0~r12,r13,r14
	3，r13，用作SP，也就是堆栈指针寄存器，c c++编译器始终默认选择r13寄存器保存堆栈指针
	4，r14寄存器用于调用返回地址，lr
	5，程序技术寄存器PC
	6，应用程序状态寄存器APSR，存放算术逻辑单元 (ALU) 状态标记的副本
	7，当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等
	8，保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR

	我们就是使用R13，硬件上的支持，就是通过堆栈指针寄存器来完成出栈入栈的控制。
	那么，栈到底有什么用？
	答：函数调用过程中的数据保存+多任务支持。

二、函数调用
	
	首先，我们需要了解一个知识点，栈帧结构和控制转移劝方式
	① 栈帧的定义：单个函数调用操作所使用的栈部分，被称为一个栈帧stack frame结构。
			通俗来说，一个函数调用，用到的栈的那部分，就是一个栈帧，所以，
			栈帧的大小跟随对应的函数调用。

	② 栈帧的结构：

			寄存器ebp,保存帧指针，指向栈帧的底部，对一个栈帧来说，是固定的
			寄存器esp,保存栈指针，指向栈帧的顶部，对一个栈帧来说，是变化的
			《Linux完全注释》有一个讲解例子，这里就先不提

	


三、多任务支持

	保存当前任务的信息，切换到另外一个进程的信息，即可完成进程切换。
	
	进程栈---进程的用户栈
	线程栈---注意，这个线程栈不能动态增长，可以用完。
		因为，线程可以并行执行，如果线程共享进程的栈，那就会出现出题。
		所以，线程栈是独立的。
		
		pthread_attr_setstack(&tattr,stack,16*1024*1024); //分配线程的栈空间
		线程栈的大小固定。	


	内核栈---我们知道，在进程切换的时候，需要内核栈来保存用户栈的地址，也就是保护当前进程的现场。
	切换过程描述：A进程的用户栈地址保存到内核栈，堆栈指针寄存器指向进程B的用户栈地址，
	就可以完成切换，而且每个进程拥有自己的内核栈，线程也拥有独立的内核栈。




四、中断栈

	第一个说法：
	X86，中断栈独立于内核栈，拥有自己的地址空间，大小8kb
	arm，中断栈共享与内核栈

	第二个说法：
	如果进程的内核栈8KB，那么所有的异常、中断、软中断使用的栈在这个内核栈中共享
	如果进程的内核栈4KB，那么硬中断、软中断都会使用独立的一个栈。

	

五、总结：
	1，每个进程拥有自己独立的用户栈、内核栈。
	2，进程执行的时候，会把当前进程的堆栈地址保存在堆栈指针寄存器中，进程切换，
		也是通过切换堆栈指针寄存器中保存的地址进程切换。


