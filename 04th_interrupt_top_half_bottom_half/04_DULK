<深入理解Linux内核>
内容主要涉及
	1，外设硬件如何引起中断
	2，中断描述表-中断所需的数据结构
	3，软件如何处理中断信号

一、基本概念
	
	1，中断分为同步中断、异步中断
		同步中断：中断的产生在CPU一条指令执行完之后，由CPU控制单元发出的中断。
			注意两点，CPU内部产出、指令执行完，所以，Inter微处理器手册中，也成为异常。

		异步中断：由其他硬件设备依照CPU时钟信号随机产生的。
			注意两点：外部硬件设备、伴随CPU时钟信号随机，所以也得知中断也有一个很小很小
			很小很小的时刻，我们可以当成立即产出。

	2，中断处理时发生中断怎么办？
		中断处理的时候，我们当然可以禁止其他中断，但这不是我们性能所要想要。
		所以，一般情况下，中断处理的时候是允许中断发生，比如并行处理中断。
		但是请注意一点，中断不能嵌套，也就是在处理中断的时候，再处理其他中断。
		而且注意，中断需要保护临界资源，这个是必须禁止并发访问的。


	3，中断、异常的分类
		中断：可屏蔽中断（IO设备）+非屏蔽中断（硬件故障等危急事件）

		异常：（取决于保存在内核堆栈中的eip寄存器中的值大概分成3~4种）
			fault故障，可以纠正，纠正后重新执行，比如缺页。
			缺页发生的时候，eip寄存器保存引起缺页异常的指令，在纠正后重新执行。

		
			trap陷阱，eip保存下一条执行的指令，比如打断电。
			打断点的时候，eip保存下一条执行的指令，断点后继续执行的下一条指令。
			一般用于调试。
			这里也纠正之前我一直说的，异常就是CPU内部产生的，解决错误后重新执行的概念。
			异常，只是表示从CPU内部控制单元发出的，当一条指令执行完之后的一个中断。
			它返回后的处理会根据保存到eip寄存器中的指令来分类故障、陷阱。


			abort异常终止，发生一个严重错误，eip无法保存指令的地址，程序直接终止。

			编程异常，溢出、越界等，也是直接终止。


二、外设硬件中断设计

				CPU0				CPU1

				本地APIC			本地APIC

					中断控制器通信总线
				|-----------------------------------|
						|||
						IO APIC
						| IRQ
						外设

	1，来自外部的中断IRQ怎么在SMP中分发？
		有两种方式
		① 静态分发
			重定向表 相应项中所列出来的本地APIC对应的CPU。
		② 动态分发
			如果某个CPU空闲或者处理最低优先级的进程，那么就发给它。
			如果有多个优先级相等的CPU，那么就需要仲裁，利用优先级寄存器仲裁。


		
	2，x86发布了20种不同的异常，使用0~19中断号。
		比如常见的
			0	故障，被0除
			3	陷阱，打断点
			11	引用不存在的内存，段错误1
			12	越界访问，段错误2
			14	缺页异常
					

	3，中断描述符表
		Interrupt Descriptor Table IDT
		这个表就是我们中断号去索引中断处理程序的入口。
		如果还要细分，还能分成3种类型的描述符，也就是这个表包含三种类型：
		任务门
		中断门
		陷阱门


	4，中断和异常的硬件处理
		

	5，中断和异常处理程序的嵌套执行
		每一个中断或者异常，都会引起一个内核控制路径。
		这个内核控制路径，就是代表当前进程被中断后陷入内核态执行的指令序列。

		请注意，现在不允许中断嵌套：
		https://www.cnblogs.com/linuxdev/p/11839005.html
		简单的说，就是从10年的一个patch合入主线后，中断嵌套就变成历史，包括
		代码里面也没有当年允许中断嵌套的一些宏或者标识字段。
		patch地址：
	https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc		
		





			

