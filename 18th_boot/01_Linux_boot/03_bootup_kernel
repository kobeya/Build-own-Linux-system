【内核启动】

	前面介绍了bootloader为内核的启动做足了工作，又是初始化硬件，又是设置启动模式，又是传递
	启动参数。我们知道内核是一个操作系统的核心，bootloader启动完后就直接消失了，剩下就是内核
	的工作，那么，这个内核在启动过程又做了些什么事情，我们应该怎么解读这个流程呢？

	最好能跟着内核中arch下的启动代码分析

【二、内核的格式】
	内核启动也分两种情况可以讨论
	1，Image格式，这是编译后，没有经过压缩的内核镜像
	2，zImage格式，这是编译后，将Image压缩后的内核镜像
		zImage的开头，有解压缩的代码，zImage的启动要比Image要慢一点，但是优点是可以节省内存
		空间，这对内存紧凑的设备来说，是可取的。


【三、内核入口前】
	前面描述了，就比如我们现在的设备，使用了zImage的内核镜像，那么在找到内核入口之前，
	还需要做一些事情。
	
	1，zImage的入口程序
	 arch/arm/boot/compressed/head.S
		1）开启MMU
		2）开启cache
		3）调用decompress_kernel解压内核
		4）调用call_kernel进入非压缩内核的Image启动流程


【四、内核启动】

	2，Image的启动流程
	不同体系的启动流程是不同的，在ARM中
	arch/arm/kernel/head-armv.S
		1）在上面代码的stext段中，这个段的基地址就是压缩内核解压缩后跳转的地址，也就是Image
			镜像的启动入口。
		2）查找处理器内核类型，也就是匹配bootloader传递过来的启动参数，做初始化动作
		3）建立页表等一系列体系相关的初始化动作
		4）跳转到c程序的入口函数，start_kernel
		

	3，start_kernel
		调用setup_arch()做与体系相关剩余的与硬件相关的初始化工作
		1）创建异常向量表、初始化中断处理函数
		2）初始化系统核心进程调度器和时钟中断处理机制
		3）初始化串口控制台
		4）初始化系统cache、内存管理、内存大小和内核占用情况
		5）初始化进程间通讯的机制等等
		6）调用rest_init函数

	4，rest_init
		做最后的初始化
		1）创建第一个进程init，结束内核的启动
		2）init进程首先进行一系列的硬件初始化，然后通过命令行的方式，写到脚本中的命令行
			挂在根文件系统
		3）最后init进程还会执行用户空间传递的init启动参数
		4）当这一切准备就绪，cpu_idle函数就会被调用，系统执行idle进程并等待用户程序的执行




		
总结：内核启动流程

	1，启动准备
		1）如果内核是zImage格式，需要先到arch目录下的head.S做解压缩，然后再跳转到
		2）Image格式的入口head-armv.S中的入口函数做启动

	2，start_kernel
		1）做与系统核心相关的初始化，比如各种机制的初始化，中断向量表、中断处理函数机制等
	
	3，rest_init
		启动init进程，做用户空间的初始化，挂在文件系统

	
	
























